# TypeScript Type Challenges 解説

## 03060 - Unshift

### 問題

```Array.unshift```の型バージョンを実装します。

例えば：

```typescript
type Result = Unshift<[1, 2], 0> // [0, 1, 2]
```

### 解答

```typescript
type Unshift<T extends any[], U extends any> = [U, ...T]
```

### 解説

#### 構文要素

**1. `T extends any[]`**

- `any[]`: 配列型を表す
- `T extends any[]`: T が配列型でなければならないという制約（ジェネリック制約）
- これにより、配列以外の型（例: 文字列や数値）を渡すとコンパイルエラーになります
- 型安全性を保証する重要な仕組み

**2. `U extends any`**

- U は任意の型を受け入れる
- `extends any` は実質的に制約がないことを意味する
- 配列の先頭に追加する要素の型として、どのような型でも許容する

**3. `[U, ...T]`**

- Tuple（タプル）型とスプレッド構文の組み合わせ
- `U`: 配列の最初の要素として U を配置
- `...T`: スプレッド構文により、T（配列型）のすべての要素を展開
- 例: `U` が `0` で `T` が `[1, 2]` なら、`[0, ...T]` は `[0, 1, 2]` となる
- これにより、新しい要素を配列の先頭に追加した新しい型が生成される

#### 実行フロー

1. **ジェネリック型の受け取り**
   - `T`: 元の配列型（例: `[1, 2]`）
   - `U`: 先頭に追加する要素の型（例: `0`）

2. **制約チェック**
   - `T extends any[]` により、T が配列型であることを検証
   - 配列以外の型が渡された場合、コンパイル時にエラーが発生

3. **新しい配列型の構築**
   - `[U, ...T]` により、U を最初の要素とし、T の要素を展開した新しいタプル型を作成
   - 元の配列の型情報を保持したまま、新しい要素が先頭に追加される

#### 実行例

**例1: 基本的な使用**
```typescript
type Result = Unshift<[1, 2], 0>
```

1. `T` は `[1, 2]`、`U` は `0`
2. `T extends any[]` をチェック
   - `[1, 2]` は配列型なので OK
3. `[U, ...T]` により：
   - `[0, ...[1, 2]]`
   - `[0, 1, 2]`
4. 結果の型: `[0, 1, 2]`

**例2: 空配列への追加**
```typescript
type Result = Unshift<[], 1>
```

1. `T` は `[]`、`U` は `1`
2. `T extends any[]` をチェック
   - `[]` は配列型なので OK
3. `[U, ...T]` により：
   - `[1, ...[]]`
   - `[1]`
4. 結果の型: `[1]`

**例3: 異なる型の要素**
```typescript
type Result = Unshift<['1', 2, '3'], boolean>
```

1. `T` は `['1', 2, '3']`、`U` は `boolean`
2. `T extends any[]` をチェック
   - `['1', 2, '3']` は配列型なので OK
3. `[U, ...T]` により：
   - `[boolean, ...['1', 2, '3']]`
   - `[boolean, '1', 2, '3']`
4. 結果の型: `[boolean, '1', 2, '3']`

### なぜこのように書くのか

**型安全性の確保**
- `T extends any[]` により、配列型以外を渡した場合にコンパイルエラーが発生
- ランタイムエラーを防ぎ、開発時に問題を発見できる

**簡潔性**
- タプル型とスプレッド構文を使うことで、わずか1行で実装できる
- JavaScript の配列操作と類似した直感的な記述

**型情報の保持**
- 元の配列の各要素の型が正確に保たれる
- タプル型の順序も維持される
- 型情報の損失がない

**JavaScript の unshift との対応**
```typescript
// JavaScript の実行時の動作
const arr = [1, 2];
arr.unshift(0); // arr は [0, 1, 2] になる

// TypeScript の型レベルの動作
type Result = Unshift<[1, 2], 0>; // [0, 1, 2]
```
- JavaScript の `unshift` メソッドと同じ動作を型レベルで実現
- 実行時とコンパイル時で一貫した動作を保証
